#!/bin/bash

function push_state {
    project_dir=$(pwd)
    project_name=$(basename $project_dir)
    backup_dir=$(dirname $project_dir)/saveWork_bkup
    mkdir -p $backup_dir

    timestamp=$(date +%Y%m%d%H%M%S)
    backup_file="$backup_dir/backup-$project_name-$timestamp.tar.gz"
    tar -czf $backup_file -C $project_dir .
    echo "Pushed state: $backup_file"
}


function pop_state {
    project_dir=$(pwd)
    project_name=$(basename $project_dir)
    backup_dir=$(dirname $project_dir)/saveWork_bkup

    latest_backup=$(ls -t $backup_dir/backup-$project_name-*.tar.gz | head -n 1)

    if [ -z "$latest_backup" ]; then
        echo "No saved states to pop."
    else
        if [ "$2" != "merge" ]; then
	    echo "clean restore"
            rm -r $project_dir/*
	else
	    echo "restoring into existing subtree "
        fi
        tar -xzf $latest_backup -C $project_dir
        rm $latest_backup
        echo "Popped state: $latest_backup"
    fi
}


function restore_state {
    project_dir=$(pwd)
    project_name=$(basename $project_dir)
    backup_dir=$(dirname $project_dir)/saveWork_bkup

    latest_backup=$(ls -t $backup_dir/backup-$project_name-*.tar.gz | head -n 1)

    if [ -z "$latest_backup" ]; then
        echo "No saved states to pop."
    else
        if [ "$2" != "merge" ]; then
	    echo "clean restore"
            rm -r $project_dir/*
	else
	    echo " restoring into existing subtree "
	fi
        tar -xzf $latest_backup -C $project_dir
        echo "restored state: $latest_backup"
    fi
}

function list_states {
    project_dir=$(pwd)
    project_name=$(basename $project_dir)
    backup_dir=$(dirname $project_dir)/saveWork_bkup
    backup_files=$(ls -t $backup_dir/backup-$project_name-*.tar.gz)

    if [ -z "$backup_files" ]; then
        echo "No saved states."
    else
        echo "Saved states:"
        for backup_file in $backup_files
        do
            timestamp=$(echo $backup_file | grep -o '[0-9]\{14\}')
            formatted_timestamp=$(date -j -f "%Y%m%d%H%M%S" "$timestamp" "+%Y-%m-%d %H:%M:%S")
            echo "$backup_file (created at $formatted_timestamp)"
        done
    fi
}

function duplicate_state {
    if [ -z "$2" ]; then
        echo "Please specify a directory for the duplicate state."
        exit 1
    fi

    project_dir=$(pwd)
    project_name=$(basename $project_dir)
    backup_dir=$(dirname $project_dir)/saveWork_bkup

    latest_backup=$(ls -t $backup_dir/backup-$project_name-*.tar.gz | head -n 1)

    if [ -z "$latest_backup" ]; then
        echo "No saved states to duplicate."
        exit 1
    else
        mkdir -p $2
        tar -xzf $latest_backup -C $2
        echo "Duplicated state to: $2"
    fi
}


case "$1" in
    push)
        push_state
        ;;
    pop)
        pop_state
        ;;
    list)
        list_states
        ;;
    duplicate)
	duplicate_state
	;;
    restore)
	restore_state
	;;
    *)
        echo "Usage: $0 {push|duplicate <pathspec>|pop [over]|restore [over]}"
	echo "  push      -- make a tgz of the tree rooted at the cwd, push it into a stack named ''saveWork_bkup''"
        echo "               in the  directory above the cwd."
	echo "  duplicate --  makes a copy of the latest backup at the given <pathspec>"
	echo "  list      -- list the backups currently available for the cwd."
	echo "  pop       -- restore the last saved tarball of the cwd, and delete the tarball afterwards."
	echo "  restore   -- restore the last saved tarball of the cwd, but do not delete the tarball afterwards."
	echo ""
	echo "               by default,  pop and restore wipe the subtree at cwd before restoring; the ''over'' option to"
	echo "               pop and restore causes the backup to be restored into/over the existing cwd; "
	echo ""
esac
